// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package shop_query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"app/internal/orm/shop_model"
)

func newGoodsCategory(db *gorm.DB, opts ...gen.DOOption) goodsCategory {
	_goodsCategory := goodsCategory{}

	_goodsCategory.goodsCategoryDo.UseDB(db, opts...)
	_goodsCategory.goodsCategoryDo.UseModel(&shop_model.GoodsCategory{})

	tableName := _goodsCategory.goodsCategoryDo.TableName()
	_goodsCategory.ALL = field.NewAsterisk(tableName)
	_goodsCategory.CategoryID = field.NewInt32(tableName, "category_id")
	_goodsCategory.SiteID = field.NewInt32(tableName, "site_id")
	_goodsCategory.CategoryName = field.NewString(tableName, "category_name")
	_goodsCategory.ShortName = field.NewString(tableName, "short_name")
	_goodsCategory.Pid = field.NewInt32(tableName, "pid")
	_goodsCategory.Level = field.NewInt32(tableName, "level")
	_goodsCategory.IsShow = field.NewInt32(tableName, "is_show")
	_goodsCategory.Sort = field.NewInt32(tableName, "sort")
	_goodsCategory.Image = field.NewString(tableName, "image")
	_goodsCategory.Keywords = field.NewString(tableName, "keywords")
	_goodsCategory.Description = field.NewString(tableName, "description")
	_goodsCategory.AttrClassID = field.NewInt32(tableName, "attr_class_id")
	_goodsCategory.AttrClassName = field.NewString(tableName, "attr_class_name")
	_goodsCategory.CategoryId1 = field.NewInt32(tableName, "category_id_1")
	_goodsCategory.CategoryId2 = field.NewInt32(tableName, "category_id_2")
	_goodsCategory.CategoryId3 = field.NewInt32(tableName, "category_id_3")
	_goodsCategory.CategoryFullName = field.NewString(tableName, "category_full_name")
	_goodsCategory.ImageAdv = field.NewString(tableName, "image_adv")
	_goodsCategory.CommissionRate = field.NewFloat64(tableName, "commission_rate")
	_goodsCategory.IsGoods = field.NewInt32(tableName, "is_goods")

	_goodsCategory.fillFieldMap()

	return _goodsCategory
}

// goodsCategory  商品分类
type goodsCategory struct {
	goodsCategoryDo

	ALL              field.Asterisk
	CategoryID       field.Int32
	SiteID           field.Int32   // 站点id
	CategoryName     field.String  // 分类名称
	ShortName        field.String  // 简称
	Pid              field.Int32   // 分类上级
	Level            field.Int32   // 层级
	IsShow           field.Int32   // 是否显示（0显示  -1不显示）
	Sort             field.Int32   // 排序
	Image            field.String  // 分类图片
	Keywords         field.String  // 分类页面关键字
	Description      field.String  // 分类介绍
	AttrClassID      field.Int32   // 关联商品类型id
	AttrClassName    field.String  // 关联商品类型名称
	CategoryId1      field.Int32   // 一级分类id
	CategoryId2      field.Int32   // 二级分类id
	CategoryId3      field.Int32   // 三级分类id
	CategoryFullName field.String  // 组装名称
	ImageAdv         field.String  // 分类广告图
	CommissionRate   field.Float64 // 佣金比率%
	IsGoods          field.Int32   // 是否渲染商品

	fieldMap map[string]field.Expr
}

func (g goodsCategory) Table(newTableName string) *goodsCategory {
	g.goodsCategoryDo.UseTable(newTableName)
	return g.updateTableName(newTableName)
}

func (g goodsCategory) As(alias string) *goodsCategory {
	g.goodsCategoryDo.DO = *(g.goodsCategoryDo.As(alias).(*gen.DO))
	return g.updateTableName(alias)
}

func (g *goodsCategory) updateTableName(table string) *goodsCategory {
	g.ALL = field.NewAsterisk(table)
	g.CategoryID = field.NewInt32(table, "category_id")
	g.SiteID = field.NewInt32(table, "site_id")
	g.CategoryName = field.NewString(table, "category_name")
	g.ShortName = field.NewString(table, "short_name")
	g.Pid = field.NewInt32(table, "pid")
	g.Level = field.NewInt32(table, "level")
	g.IsShow = field.NewInt32(table, "is_show")
	g.Sort = field.NewInt32(table, "sort")
	g.Image = field.NewString(table, "image")
	g.Keywords = field.NewString(table, "keywords")
	g.Description = field.NewString(table, "description")
	g.AttrClassID = field.NewInt32(table, "attr_class_id")
	g.AttrClassName = field.NewString(table, "attr_class_name")
	g.CategoryId1 = field.NewInt32(table, "category_id_1")
	g.CategoryId2 = field.NewInt32(table, "category_id_2")
	g.CategoryId3 = field.NewInt32(table, "category_id_3")
	g.CategoryFullName = field.NewString(table, "category_full_name")
	g.ImageAdv = field.NewString(table, "image_adv")
	g.CommissionRate = field.NewFloat64(table, "commission_rate")
	g.IsGoods = field.NewInt32(table, "is_goods")

	g.fillFieldMap()

	return g
}

func (g *goodsCategory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := g.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (g *goodsCategory) fillFieldMap() {
	g.fieldMap = make(map[string]field.Expr, 20)
	g.fieldMap["category_id"] = g.CategoryID
	g.fieldMap["site_id"] = g.SiteID
	g.fieldMap["category_name"] = g.CategoryName
	g.fieldMap["short_name"] = g.ShortName
	g.fieldMap["pid"] = g.Pid
	g.fieldMap["level"] = g.Level
	g.fieldMap["is_show"] = g.IsShow
	g.fieldMap["sort"] = g.Sort
	g.fieldMap["image"] = g.Image
	g.fieldMap["keywords"] = g.Keywords
	g.fieldMap["description"] = g.Description
	g.fieldMap["attr_class_id"] = g.AttrClassID
	g.fieldMap["attr_class_name"] = g.AttrClassName
	g.fieldMap["category_id_1"] = g.CategoryId1
	g.fieldMap["category_id_2"] = g.CategoryId2
	g.fieldMap["category_id_3"] = g.CategoryId3
	g.fieldMap["category_full_name"] = g.CategoryFullName
	g.fieldMap["image_adv"] = g.ImageAdv
	g.fieldMap["commission_rate"] = g.CommissionRate
	g.fieldMap["is_goods"] = g.IsGoods
}

func (g goodsCategory) clone(db *gorm.DB) goodsCategory {
	g.goodsCategoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return g
}

func (g goodsCategory) replaceDB(db *gorm.DB) goodsCategory {
	g.goodsCategoryDo.ReplaceDB(db)
	return g
}

type goodsCategoryDo struct{ gen.DO }

type IGoodsCategoryDo interface {
	gen.SubQuery
	Debug() IGoodsCategoryDo
	WithContext(ctx context.Context) IGoodsCategoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IGoodsCategoryDo
	WriteDB() IGoodsCategoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IGoodsCategoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IGoodsCategoryDo
	Not(conds ...gen.Condition) IGoodsCategoryDo
	Or(conds ...gen.Condition) IGoodsCategoryDo
	Select(conds ...field.Expr) IGoodsCategoryDo
	Where(conds ...gen.Condition) IGoodsCategoryDo
	Order(conds ...field.Expr) IGoodsCategoryDo
	Distinct(cols ...field.Expr) IGoodsCategoryDo
	Omit(cols ...field.Expr) IGoodsCategoryDo
	Join(table schema.Tabler, on ...field.Expr) IGoodsCategoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IGoodsCategoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IGoodsCategoryDo
	Group(cols ...field.Expr) IGoodsCategoryDo
	Having(conds ...gen.Condition) IGoodsCategoryDo
	Limit(limit int) IGoodsCategoryDo
	Offset(offset int) IGoodsCategoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IGoodsCategoryDo
	Unscoped() IGoodsCategoryDo
	Create(values ...*shop_model.GoodsCategory) error
	CreateInBatches(values []*shop_model.GoodsCategory, batchSize int) error
	Save(values ...*shop_model.GoodsCategory) error
	First() (*shop_model.GoodsCategory, error)
	Take() (*shop_model.GoodsCategory, error)
	Last() (*shop_model.GoodsCategory, error)
	Find() ([]*shop_model.GoodsCategory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*shop_model.GoodsCategory, err error)
	FindInBatches(result *[]*shop_model.GoodsCategory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*shop_model.GoodsCategory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IGoodsCategoryDo
	Assign(attrs ...field.AssignExpr) IGoodsCategoryDo
	Joins(fields ...field.RelationField) IGoodsCategoryDo
	Preload(fields ...field.RelationField) IGoodsCategoryDo
	FirstOrInit() (*shop_model.GoodsCategory, error)
	FirstOrCreate() (*shop_model.GoodsCategory, error)
	FindByPage(offset int, limit int) (result []*shop_model.GoodsCategory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IGoodsCategoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (g goodsCategoryDo) Debug() IGoodsCategoryDo {
	return g.withDO(g.DO.Debug())
}

func (g goodsCategoryDo) WithContext(ctx context.Context) IGoodsCategoryDo {
	return g.withDO(g.DO.WithContext(ctx))
}

func (g goodsCategoryDo) ReadDB() IGoodsCategoryDo {
	return g.Clauses(dbresolver.Read)
}

func (g goodsCategoryDo) WriteDB() IGoodsCategoryDo {
	return g.Clauses(dbresolver.Write)
}

func (g goodsCategoryDo) Session(config *gorm.Session) IGoodsCategoryDo {
	return g.withDO(g.DO.Session(config))
}

func (g goodsCategoryDo) Clauses(conds ...clause.Expression) IGoodsCategoryDo {
	return g.withDO(g.DO.Clauses(conds...))
}

func (g goodsCategoryDo) Returning(value interface{}, columns ...string) IGoodsCategoryDo {
	return g.withDO(g.DO.Returning(value, columns...))
}

func (g goodsCategoryDo) Not(conds ...gen.Condition) IGoodsCategoryDo {
	return g.withDO(g.DO.Not(conds...))
}

func (g goodsCategoryDo) Or(conds ...gen.Condition) IGoodsCategoryDo {
	return g.withDO(g.DO.Or(conds...))
}

func (g goodsCategoryDo) Select(conds ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.Select(conds...))
}

func (g goodsCategoryDo) Where(conds ...gen.Condition) IGoodsCategoryDo {
	return g.withDO(g.DO.Where(conds...))
}

func (g goodsCategoryDo) Order(conds ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.Order(conds...))
}

func (g goodsCategoryDo) Distinct(cols ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.Distinct(cols...))
}

func (g goodsCategoryDo) Omit(cols ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.Omit(cols...))
}

func (g goodsCategoryDo) Join(table schema.Tabler, on ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.Join(table, on...))
}

func (g goodsCategoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.LeftJoin(table, on...))
}

func (g goodsCategoryDo) RightJoin(table schema.Tabler, on ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.RightJoin(table, on...))
}

func (g goodsCategoryDo) Group(cols ...field.Expr) IGoodsCategoryDo {
	return g.withDO(g.DO.Group(cols...))
}

func (g goodsCategoryDo) Having(conds ...gen.Condition) IGoodsCategoryDo {
	return g.withDO(g.DO.Having(conds...))
}

func (g goodsCategoryDo) Limit(limit int) IGoodsCategoryDo {
	return g.withDO(g.DO.Limit(limit))
}

func (g goodsCategoryDo) Offset(offset int) IGoodsCategoryDo {
	return g.withDO(g.DO.Offset(offset))
}

func (g goodsCategoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IGoodsCategoryDo {
	return g.withDO(g.DO.Scopes(funcs...))
}

func (g goodsCategoryDo) Unscoped() IGoodsCategoryDo {
	return g.withDO(g.DO.Unscoped())
}

func (g goodsCategoryDo) Create(values ...*shop_model.GoodsCategory) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Create(values)
}

func (g goodsCategoryDo) CreateInBatches(values []*shop_model.GoodsCategory, batchSize int) error {
	return g.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (g goodsCategoryDo) Save(values ...*shop_model.GoodsCategory) error {
	if len(values) == 0 {
		return nil
	}
	return g.DO.Save(values)
}

func (g goodsCategoryDo) First() (*shop_model.GoodsCategory, error) {
	if result, err := g.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.GoodsCategory), nil
	}
}

func (g goodsCategoryDo) Take() (*shop_model.GoodsCategory, error) {
	if result, err := g.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.GoodsCategory), nil
	}
}

func (g goodsCategoryDo) Last() (*shop_model.GoodsCategory, error) {
	if result, err := g.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.GoodsCategory), nil
	}
}

func (g goodsCategoryDo) Find() ([]*shop_model.GoodsCategory, error) {
	result, err := g.DO.Find()
	return result.([]*shop_model.GoodsCategory), err
}

func (g goodsCategoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*shop_model.GoodsCategory, err error) {
	buf := make([]*shop_model.GoodsCategory, 0, batchSize)
	err = g.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (g goodsCategoryDo) FindInBatches(result *[]*shop_model.GoodsCategory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return g.DO.FindInBatches(result, batchSize, fc)
}

func (g goodsCategoryDo) Attrs(attrs ...field.AssignExpr) IGoodsCategoryDo {
	return g.withDO(g.DO.Attrs(attrs...))
}

func (g goodsCategoryDo) Assign(attrs ...field.AssignExpr) IGoodsCategoryDo {
	return g.withDO(g.DO.Assign(attrs...))
}

func (g goodsCategoryDo) Joins(fields ...field.RelationField) IGoodsCategoryDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Joins(_f))
	}
	return &g
}

func (g goodsCategoryDo) Preload(fields ...field.RelationField) IGoodsCategoryDo {
	for _, _f := range fields {
		g = *g.withDO(g.DO.Preload(_f))
	}
	return &g
}

func (g goodsCategoryDo) FirstOrInit() (*shop_model.GoodsCategory, error) {
	if result, err := g.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.GoodsCategory), nil
	}
}

func (g goodsCategoryDo) FirstOrCreate() (*shop_model.GoodsCategory, error) {
	if result, err := g.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.GoodsCategory), nil
	}
}

func (g goodsCategoryDo) FindByPage(offset int, limit int) (result []*shop_model.GoodsCategory, count int64, err error) {
	result, err = g.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = g.Offset(-1).Limit(-1).Count()
	return
}

func (g goodsCategoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = g.Count()
	if err != nil {
		return
	}

	err = g.Offset(offset).Limit(limit).Scan(result)
	return
}

func (g goodsCategoryDo) Scan(result interface{}) (err error) {
	return g.DO.Scan(result)
}

func (g goodsCategoryDo) Delete(models ...*shop_model.GoodsCategory) (result gen.ResultInfo, err error) {
	return g.DO.Delete(models)
}

func (g *goodsCategoryDo) withDO(do gen.Dao) *goodsCategoryDo {
	g.DO = *do.(*gen.DO)
	return g
}
