// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package shop_query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"app/internal/orm/shop_model"
)

func newErpOrderOutbound(db *gorm.DB, opts ...gen.DOOption) erpOrderOutbound {
	_erpOrderOutbound := erpOrderOutbound{}

	_erpOrderOutbound.erpOrderOutboundDo.UseDB(db, opts...)
	_erpOrderOutbound.erpOrderOutboundDo.UseModel(&shop_model.ErpOrderOutbound{})

	tableName := _erpOrderOutbound.erpOrderOutboundDo.TableName()
	_erpOrderOutbound.ALL = field.NewAsterisk(tableName)
	_erpOrderOutbound.ID = field.NewInt32(tableName, "id")
	_erpOrderOutbound.OutboundNo = field.NewString(tableName, "outbound_no")
	_erpOrderOutbound.OrderNo = field.NewString(tableName, "order_no")
	_erpOrderOutbound.GoodsErpSpid = field.NewString(tableName, "goods_erp_spid")
	_erpOrderOutbound.OutboundTime = field.NewString(tableName, "outbound_time")
	_erpOrderOutbound.Validity = field.NewString(tableName, "validity")
	_erpOrderOutbound.OutboundNum = field.NewInt32(tableName, "outbound_num")
	_erpOrderOutbound.OutboundPrice = field.NewFloat64(tableName, "outbound_price")
	_erpOrderOutbound.LogisticsCompany = field.NewString(tableName, "logistics_company")
	_erpOrderOutbound.LogisticsCode = field.NewString(tableName, "logistics_code")
	_erpOrderOutbound.SyncTime = field.NewTime(tableName, "sync_time")

	_erpOrderOutbound.fillFieldMap()

	return _erpOrderOutbound
}

type erpOrderOutbound struct {
	erpOrderOutboundDo

	ALL              field.Asterisk
	ID               field.Int32
	OutboundNo       field.String  // 出库单据编号
	OrderNo          field.String  // 订单编号
	GoodsErpSpid     field.String  // 商品erpid
	OutboundTime     field.String  // 出库时间
	Validity         field.String  // 出库的商品效期
	OutboundNum      field.Int32   // 实际出库数量
	OutboundPrice    field.Float64 // 实际出库单价
	LogisticsCompany field.String  // 物流公司名称，需与电商后台相同，如非物流发货传"无需物流"
	LogisticsCode    field.String  // 运单号，无需物流时传空字符串
	SyncTime         field.Time    // 同步的时间

	fieldMap map[string]field.Expr
}

func (e erpOrderOutbound) Table(newTableName string) *erpOrderOutbound {
	e.erpOrderOutboundDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e erpOrderOutbound) As(alias string) *erpOrderOutbound {
	e.erpOrderOutboundDo.DO = *(e.erpOrderOutboundDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *erpOrderOutbound) updateTableName(table string) *erpOrderOutbound {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewInt32(table, "id")
	e.OutboundNo = field.NewString(table, "outbound_no")
	e.OrderNo = field.NewString(table, "order_no")
	e.GoodsErpSpid = field.NewString(table, "goods_erp_spid")
	e.OutboundTime = field.NewString(table, "outbound_time")
	e.Validity = field.NewString(table, "validity")
	e.OutboundNum = field.NewInt32(table, "outbound_num")
	e.OutboundPrice = field.NewFloat64(table, "outbound_price")
	e.LogisticsCompany = field.NewString(table, "logistics_company")
	e.LogisticsCode = field.NewString(table, "logistics_code")
	e.SyncTime = field.NewTime(table, "sync_time")

	e.fillFieldMap()

	return e
}

func (e *erpOrderOutbound) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *erpOrderOutbound) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 11)
	e.fieldMap["id"] = e.ID
	e.fieldMap["outbound_no"] = e.OutboundNo
	e.fieldMap["order_no"] = e.OrderNo
	e.fieldMap["goods_erp_spid"] = e.GoodsErpSpid
	e.fieldMap["outbound_time"] = e.OutboundTime
	e.fieldMap["validity"] = e.Validity
	e.fieldMap["outbound_num"] = e.OutboundNum
	e.fieldMap["outbound_price"] = e.OutboundPrice
	e.fieldMap["logistics_company"] = e.LogisticsCompany
	e.fieldMap["logistics_code"] = e.LogisticsCode
	e.fieldMap["sync_time"] = e.SyncTime
}

func (e erpOrderOutbound) clone(db *gorm.DB) erpOrderOutbound {
	e.erpOrderOutboundDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e erpOrderOutbound) replaceDB(db *gorm.DB) erpOrderOutbound {
	e.erpOrderOutboundDo.ReplaceDB(db)
	return e
}

type erpOrderOutboundDo struct{ gen.DO }

type IErpOrderOutboundDo interface {
	gen.SubQuery
	Debug() IErpOrderOutboundDo
	WithContext(ctx context.Context) IErpOrderOutboundDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IErpOrderOutboundDo
	WriteDB() IErpOrderOutboundDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IErpOrderOutboundDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IErpOrderOutboundDo
	Not(conds ...gen.Condition) IErpOrderOutboundDo
	Or(conds ...gen.Condition) IErpOrderOutboundDo
	Select(conds ...field.Expr) IErpOrderOutboundDo
	Where(conds ...gen.Condition) IErpOrderOutboundDo
	Order(conds ...field.Expr) IErpOrderOutboundDo
	Distinct(cols ...field.Expr) IErpOrderOutboundDo
	Omit(cols ...field.Expr) IErpOrderOutboundDo
	Join(table schema.Tabler, on ...field.Expr) IErpOrderOutboundDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IErpOrderOutboundDo
	RightJoin(table schema.Tabler, on ...field.Expr) IErpOrderOutboundDo
	Group(cols ...field.Expr) IErpOrderOutboundDo
	Having(conds ...gen.Condition) IErpOrderOutboundDo
	Limit(limit int) IErpOrderOutboundDo
	Offset(offset int) IErpOrderOutboundDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IErpOrderOutboundDo
	Unscoped() IErpOrderOutboundDo
	Create(values ...*shop_model.ErpOrderOutbound) error
	CreateInBatches(values []*shop_model.ErpOrderOutbound, batchSize int) error
	Save(values ...*shop_model.ErpOrderOutbound) error
	First() (*shop_model.ErpOrderOutbound, error)
	Take() (*shop_model.ErpOrderOutbound, error)
	Last() (*shop_model.ErpOrderOutbound, error)
	Find() ([]*shop_model.ErpOrderOutbound, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*shop_model.ErpOrderOutbound, err error)
	FindInBatches(result *[]*shop_model.ErpOrderOutbound, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*shop_model.ErpOrderOutbound) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IErpOrderOutboundDo
	Assign(attrs ...field.AssignExpr) IErpOrderOutboundDo
	Joins(fields ...field.RelationField) IErpOrderOutboundDo
	Preload(fields ...field.RelationField) IErpOrderOutboundDo
	FirstOrInit() (*shop_model.ErpOrderOutbound, error)
	FirstOrCreate() (*shop_model.ErpOrderOutbound, error)
	FindByPage(offset int, limit int) (result []*shop_model.ErpOrderOutbound, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IErpOrderOutboundDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (e erpOrderOutboundDo) Debug() IErpOrderOutboundDo {
	return e.withDO(e.DO.Debug())
}

func (e erpOrderOutboundDo) WithContext(ctx context.Context) IErpOrderOutboundDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e erpOrderOutboundDo) ReadDB() IErpOrderOutboundDo {
	return e.Clauses(dbresolver.Read)
}

func (e erpOrderOutboundDo) WriteDB() IErpOrderOutboundDo {
	return e.Clauses(dbresolver.Write)
}

func (e erpOrderOutboundDo) Session(config *gorm.Session) IErpOrderOutboundDo {
	return e.withDO(e.DO.Session(config))
}

func (e erpOrderOutboundDo) Clauses(conds ...clause.Expression) IErpOrderOutboundDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e erpOrderOutboundDo) Returning(value interface{}, columns ...string) IErpOrderOutboundDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e erpOrderOutboundDo) Not(conds ...gen.Condition) IErpOrderOutboundDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e erpOrderOutboundDo) Or(conds ...gen.Condition) IErpOrderOutboundDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e erpOrderOutboundDo) Select(conds ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e erpOrderOutboundDo) Where(conds ...gen.Condition) IErpOrderOutboundDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e erpOrderOutboundDo) Order(conds ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e erpOrderOutboundDo) Distinct(cols ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e erpOrderOutboundDo) Omit(cols ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e erpOrderOutboundDo) Join(table schema.Tabler, on ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e erpOrderOutboundDo) LeftJoin(table schema.Tabler, on ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e erpOrderOutboundDo) RightJoin(table schema.Tabler, on ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e erpOrderOutboundDo) Group(cols ...field.Expr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e erpOrderOutboundDo) Having(conds ...gen.Condition) IErpOrderOutboundDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e erpOrderOutboundDo) Limit(limit int) IErpOrderOutboundDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e erpOrderOutboundDo) Offset(offset int) IErpOrderOutboundDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e erpOrderOutboundDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IErpOrderOutboundDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e erpOrderOutboundDo) Unscoped() IErpOrderOutboundDo {
	return e.withDO(e.DO.Unscoped())
}

func (e erpOrderOutboundDo) Create(values ...*shop_model.ErpOrderOutbound) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e erpOrderOutboundDo) CreateInBatches(values []*shop_model.ErpOrderOutbound, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e erpOrderOutboundDo) Save(values ...*shop_model.ErpOrderOutbound) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e erpOrderOutboundDo) First() (*shop_model.ErpOrderOutbound, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.ErpOrderOutbound), nil
	}
}

func (e erpOrderOutboundDo) Take() (*shop_model.ErpOrderOutbound, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.ErpOrderOutbound), nil
	}
}

func (e erpOrderOutboundDo) Last() (*shop_model.ErpOrderOutbound, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.ErpOrderOutbound), nil
	}
}

func (e erpOrderOutboundDo) Find() ([]*shop_model.ErpOrderOutbound, error) {
	result, err := e.DO.Find()
	return result.([]*shop_model.ErpOrderOutbound), err
}

func (e erpOrderOutboundDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*shop_model.ErpOrderOutbound, err error) {
	buf := make([]*shop_model.ErpOrderOutbound, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e erpOrderOutboundDo) FindInBatches(result *[]*shop_model.ErpOrderOutbound, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e erpOrderOutboundDo) Attrs(attrs ...field.AssignExpr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e erpOrderOutboundDo) Assign(attrs ...field.AssignExpr) IErpOrderOutboundDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e erpOrderOutboundDo) Joins(fields ...field.RelationField) IErpOrderOutboundDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e erpOrderOutboundDo) Preload(fields ...field.RelationField) IErpOrderOutboundDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e erpOrderOutboundDo) FirstOrInit() (*shop_model.ErpOrderOutbound, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.ErpOrderOutbound), nil
	}
}

func (e erpOrderOutboundDo) FirstOrCreate() (*shop_model.ErpOrderOutbound, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.ErpOrderOutbound), nil
	}
}

func (e erpOrderOutboundDo) FindByPage(offset int, limit int) (result []*shop_model.ErpOrderOutbound, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e erpOrderOutboundDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e erpOrderOutboundDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e erpOrderOutboundDo) Delete(models ...*shop_model.ErpOrderOutbound) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *erpOrderOutboundDo) withDO(do gen.Dao) *erpOrderOutboundDo {
	e.DO = *do.(*gen.DO)
	return e
}
