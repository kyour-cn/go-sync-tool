// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package shop_query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"app/internal/orm/shop_model"
)

func newMemberQualification(db *gorm.DB, opts ...gen.DOOption) memberQualification {
	_memberQualification := memberQualification{}

	_memberQualification.memberQualificationDo.UseDB(db, opts...)
	_memberQualification.memberQualificationDo.UseModel(&shop_model.MemberQualification{})

	tableName := _memberQualification.memberQualificationDo.TableName()
	_memberQualification.ALL = field.NewAsterisk(tableName)
	_memberQualification.ID = field.NewInt32(tableName, "id")
	_memberQualification.MemberID = field.NewInt32(tableName, "member_id")
	_memberQualification.Name = field.NewString(tableName, "name")
	_memberQualification.Identify = field.NewString(tableName, "identify")
	_memberQualification.ExpirationStartDate = field.NewTime(tableName, "expiration_start_date")
	_memberQualification.ExpirationEndDate = field.NewTime(tableName, "expiration_end_date")
	_memberQualification.LongTerm = field.NewInt32(tableName, "long_term")
	_memberQualification.Image = field.NewString(tableName, "image")
	_memberQualification.Status = field.NewInt32(tableName, "status")
	_memberQualification.CardNo = field.NewString(tableName, "card_no")
	_memberQualification.RefuseReason = field.NewString(tableName, "refuse_reason")
	_memberQualification.Custom = field.NewString(tableName, "custom")
	_memberQualification.VerifyData = field.NewString(tableName, "verify_data")

	_memberQualification.fillFieldMap()

	return _memberQualification
}

// memberQualification 会员资质
type memberQualification struct {
	memberQualificationDo

	ALL                 field.Asterisk
	ID                  field.Int32
	MemberID            field.Int32  // 用户名
	Name                field.String // 资质名称
	Identify            field.String // 资质标识
	ExpirationStartDate field.Time   // 开始时间
	ExpirationEndDate   field.Time   // 结束时间
	LongTerm            field.Int32  // 是否长期有效
	Image               field.String // 图片地址
	Status              field.Int32  // 审核状态 0 待审核 1审核通过 -1审核拒绝
	CardNo              field.String // 证件号
	RefuseReason        field.String // 拒绝原因
	Custom              field.String // 自定义表单
	VerifyData          field.String // 核实图片（审核时上传）

	fieldMap map[string]field.Expr
}

func (m memberQualification) Table(newTableName string) *memberQualification {
	m.memberQualificationDo.UseTable(newTableName)
	return m.updateTableName(newTableName)
}

func (m memberQualification) As(alias string) *memberQualification {
	m.memberQualificationDo.DO = *(m.memberQualificationDo.As(alias).(*gen.DO))
	return m.updateTableName(alias)
}

func (m *memberQualification) updateTableName(table string) *memberQualification {
	m.ALL = field.NewAsterisk(table)
	m.ID = field.NewInt32(table, "id")
	m.MemberID = field.NewInt32(table, "member_id")
	m.Name = field.NewString(table, "name")
	m.Identify = field.NewString(table, "identify")
	m.ExpirationStartDate = field.NewTime(table, "expiration_start_date")
	m.ExpirationEndDate = field.NewTime(table, "expiration_end_date")
	m.LongTerm = field.NewInt32(table, "long_term")
	m.Image = field.NewString(table, "image")
	m.Status = field.NewInt32(table, "status")
	m.CardNo = field.NewString(table, "card_no")
	m.RefuseReason = field.NewString(table, "refuse_reason")
	m.Custom = field.NewString(table, "custom")
	m.VerifyData = field.NewString(table, "verify_data")

	m.fillFieldMap()

	return m
}

func (m *memberQualification) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := m.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (m *memberQualification) fillFieldMap() {
	m.fieldMap = make(map[string]field.Expr, 13)
	m.fieldMap["id"] = m.ID
	m.fieldMap["member_id"] = m.MemberID
	m.fieldMap["name"] = m.Name
	m.fieldMap["identify"] = m.Identify
	m.fieldMap["expiration_start_date"] = m.ExpirationStartDate
	m.fieldMap["expiration_end_date"] = m.ExpirationEndDate
	m.fieldMap["long_term"] = m.LongTerm
	m.fieldMap["image"] = m.Image
	m.fieldMap["status"] = m.Status
	m.fieldMap["card_no"] = m.CardNo
	m.fieldMap["refuse_reason"] = m.RefuseReason
	m.fieldMap["custom"] = m.Custom
	m.fieldMap["verify_data"] = m.VerifyData
}

func (m memberQualification) clone(db *gorm.DB) memberQualification {
	m.memberQualificationDo.ReplaceConnPool(db.Statement.ConnPool)
	return m
}

func (m memberQualification) replaceDB(db *gorm.DB) memberQualification {
	m.memberQualificationDo.ReplaceDB(db)
	return m
}

type memberQualificationDo struct{ gen.DO }

type IMemberQualificationDo interface {
	gen.SubQuery
	Debug() IMemberQualificationDo
	WithContext(ctx context.Context) IMemberQualificationDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IMemberQualificationDo
	WriteDB() IMemberQualificationDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IMemberQualificationDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IMemberQualificationDo
	Not(conds ...gen.Condition) IMemberQualificationDo
	Or(conds ...gen.Condition) IMemberQualificationDo
	Select(conds ...field.Expr) IMemberQualificationDo
	Where(conds ...gen.Condition) IMemberQualificationDo
	Order(conds ...field.Expr) IMemberQualificationDo
	Distinct(cols ...field.Expr) IMemberQualificationDo
	Omit(cols ...field.Expr) IMemberQualificationDo
	Join(table schema.Tabler, on ...field.Expr) IMemberQualificationDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IMemberQualificationDo
	RightJoin(table schema.Tabler, on ...field.Expr) IMemberQualificationDo
	Group(cols ...field.Expr) IMemberQualificationDo
	Having(conds ...gen.Condition) IMemberQualificationDo
	Limit(limit int) IMemberQualificationDo
	Offset(offset int) IMemberQualificationDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IMemberQualificationDo
	Unscoped() IMemberQualificationDo
	Create(values ...*shop_model.MemberQualification) error
	CreateInBatches(values []*shop_model.MemberQualification, batchSize int) error
	Save(values ...*shop_model.MemberQualification) error
	First() (*shop_model.MemberQualification, error)
	Take() (*shop_model.MemberQualification, error)
	Last() (*shop_model.MemberQualification, error)
	Find() ([]*shop_model.MemberQualification, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*shop_model.MemberQualification, err error)
	FindInBatches(result *[]*shop_model.MemberQualification, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*shop_model.MemberQualification) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IMemberQualificationDo
	Assign(attrs ...field.AssignExpr) IMemberQualificationDo
	Joins(fields ...field.RelationField) IMemberQualificationDo
	Preload(fields ...field.RelationField) IMemberQualificationDo
	FirstOrInit() (*shop_model.MemberQualification, error)
	FirstOrCreate() (*shop_model.MemberQualification, error)
	FindByPage(offset int, limit int) (result []*shop_model.MemberQualification, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IMemberQualificationDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (m memberQualificationDo) Debug() IMemberQualificationDo {
	return m.withDO(m.DO.Debug())
}

func (m memberQualificationDo) WithContext(ctx context.Context) IMemberQualificationDo {
	return m.withDO(m.DO.WithContext(ctx))
}

func (m memberQualificationDo) ReadDB() IMemberQualificationDo {
	return m.Clauses(dbresolver.Read)
}

func (m memberQualificationDo) WriteDB() IMemberQualificationDo {
	return m.Clauses(dbresolver.Write)
}

func (m memberQualificationDo) Session(config *gorm.Session) IMemberQualificationDo {
	return m.withDO(m.DO.Session(config))
}

func (m memberQualificationDo) Clauses(conds ...clause.Expression) IMemberQualificationDo {
	return m.withDO(m.DO.Clauses(conds...))
}

func (m memberQualificationDo) Returning(value interface{}, columns ...string) IMemberQualificationDo {
	return m.withDO(m.DO.Returning(value, columns...))
}

func (m memberQualificationDo) Not(conds ...gen.Condition) IMemberQualificationDo {
	return m.withDO(m.DO.Not(conds...))
}

func (m memberQualificationDo) Or(conds ...gen.Condition) IMemberQualificationDo {
	return m.withDO(m.DO.Or(conds...))
}

func (m memberQualificationDo) Select(conds ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.Select(conds...))
}

func (m memberQualificationDo) Where(conds ...gen.Condition) IMemberQualificationDo {
	return m.withDO(m.DO.Where(conds...))
}

func (m memberQualificationDo) Order(conds ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.Order(conds...))
}

func (m memberQualificationDo) Distinct(cols ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.Distinct(cols...))
}

func (m memberQualificationDo) Omit(cols ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.Omit(cols...))
}

func (m memberQualificationDo) Join(table schema.Tabler, on ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.Join(table, on...))
}

func (m memberQualificationDo) LeftJoin(table schema.Tabler, on ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.LeftJoin(table, on...))
}

func (m memberQualificationDo) RightJoin(table schema.Tabler, on ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.RightJoin(table, on...))
}

func (m memberQualificationDo) Group(cols ...field.Expr) IMemberQualificationDo {
	return m.withDO(m.DO.Group(cols...))
}

func (m memberQualificationDo) Having(conds ...gen.Condition) IMemberQualificationDo {
	return m.withDO(m.DO.Having(conds...))
}

func (m memberQualificationDo) Limit(limit int) IMemberQualificationDo {
	return m.withDO(m.DO.Limit(limit))
}

func (m memberQualificationDo) Offset(offset int) IMemberQualificationDo {
	return m.withDO(m.DO.Offset(offset))
}

func (m memberQualificationDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IMemberQualificationDo {
	return m.withDO(m.DO.Scopes(funcs...))
}

func (m memberQualificationDo) Unscoped() IMemberQualificationDo {
	return m.withDO(m.DO.Unscoped())
}

func (m memberQualificationDo) Create(values ...*shop_model.MemberQualification) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Create(values)
}

func (m memberQualificationDo) CreateInBatches(values []*shop_model.MemberQualification, batchSize int) error {
	return m.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (m memberQualificationDo) Save(values ...*shop_model.MemberQualification) error {
	if len(values) == 0 {
		return nil
	}
	return m.DO.Save(values)
}

func (m memberQualificationDo) First() (*shop_model.MemberQualification, error) {
	if result, err := m.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.MemberQualification), nil
	}
}

func (m memberQualificationDo) Take() (*shop_model.MemberQualification, error) {
	if result, err := m.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.MemberQualification), nil
	}
}

func (m memberQualificationDo) Last() (*shop_model.MemberQualification, error) {
	if result, err := m.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.MemberQualification), nil
	}
}

func (m memberQualificationDo) Find() ([]*shop_model.MemberQualification, error) {
	result, err := m.DO.Find()
	return result.([]*shop_model.MemberQualification), err
}

func (m memberQualificationDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*shop_model.MemberQualification, err error) {
	buf := make([]*shop_model.MemberQualification, 0, batchSize)
	err = m.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (m memberQualificationDo) FindInBatches(result *[]*shop_model.MemberQualification, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return m.DO.FindInBatches(result, batchSize, fc)
}

func (m memberQualificationDo) Attrs(attrs ...field.AssignExpr) IMemberQualificationDo {
	return m.withDO(m.DO.Attrs(attrs...))
}

func (m memberQualificationDo) Assign(attrs ...field.AssignExpr) IMemberQualificationDo {
	return m.withDO(m.DO.Assign(attrs...))
}

func (m memberQualificationDo) Joins(fields ...field.RelationField) IMemberQualificationDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Joins(_f))
	}
	return &m
}

func (m memberQualificationDo) Preload(fields ...field.RelationField) IMemberQualificationDo {
	for _, _f := range fields {
		m = *m.withDO(m.DO.Preload(_f))
	}
	return &m
}

func (m memberQualificationDo) FirstOrInit() (*shop_model.MemberQualification, error) {
	if result, err := m.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.MemberQualification), nil
	}
}

func (m memberQualificationDo) FirstOrCreate() (*shop_model.MemberQualification, error) {
	if result, err := m.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*shop_model.MemberQualification), nil
	}
}

func (m memberQualificationDo) FindByPage(offset int, limit int) (result []*shop_model.MemberQualification, count int64, err error) {
	result, err = m.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = m.Offset(-1).Limit(-1).Count()
	return
}

func (m memberQualificationDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = m.Count()
	if err != nil {
		return
	}

	err = m.Offset(offset).Limit(limit).Scan(result)
	return
}

func (m memberQualificationDo) Scan(result interface{}) (err error) {
	return m.DO.Scan(result)
}

func (m memberQualificationDo) Delete(models ...*shop_model.MemberQualification) (result gen.ResultInfo, err error) {
	return m.DO.Delete(models)
}

func (m *memberQualificationDo) withDO(do gen.Dao) *memberQualificationDo {
	m.DO = *do.(*gen.DO)
	return m
}
